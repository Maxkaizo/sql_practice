# üìù Technical Notes and Design Decisions

This document contains key implementation details, lessons learned, and configuration decisions taken while building the SQL practice environment.

---

## üìå Decision: Using **Bind Mounts** instead of Named Volumes

To maintain full visibility and control over the files generated by PostgreSQL and PgAdmin, we chose to use **bind mounts** instead of Docker-managed named volumes.

This allows for:

- Easier manual inspection of internal database files.
- Flexible backup and version control.
- Greater transparency during learning and troubleshooting.

```yaml
volumes:
  - "./data/persistent/postgres_data:/var/lib/postgresql/data:rw"
  - "./data/persistent/pgadmin_data:/var/lib/pgadmin:rw"
```

## Dev Tips

### PgAdmin Permissions Issue

The official `dpage/pgadmin4` image runs as a non-root user with **UID 5050**.

When mounting a host directory to `/var/lib/pgadmin`, the container may fail to start with a permission error like:

```
ERROR: Failed to create the directory /var/lib/pgadmin/sessions: Permission denied
```

#### ‚úÖ Solution

Manually set ownership of the mounted directory to UID `5050`:

```bash
sudo chown -R 5050:5050 ./data/persistent/pgadmin_data
```

This grants PgAdmin permission to create necessary internal folders such as `sessions/`, `storage/`, and the SQLite config file `pgadmin4.db`.

---

### 

Perfecto, aqu√≠ tienes el extracto reformulado con ese enfoque comparativo:

---

### Table Creation ‚Äì Differences Between `to_sql()` and Raw SQL with `engine.connect()`

There are many ways to create tables in PostgreSQL using Python and SQLAlchemy. Two common approaches are:

1. Using `pandas.DataFrame.to_sql()`
2. Executing raw SQL through `engine.connect()` or `engine.begin()`

While both can be used effectively, **they differ in how they handle transactions**:

* `to_sql()` handles the entire operation internally ‚Äî including opening the connection, creating the table, and committing the transaction. For example:

  ```python
  df.head(n=0).to_sql(name='yellow_taxi_data', con=engine, if_exists='replace')
  ```

  This will create (or replace) the table **without needing to call `commit()` explicitly**.

* In contrast, when you execute raw SQL using `engine.connect()` and a cursor (or SQLAlchemy‚Äôs `execute()`), you are responsible for managing the transaction lifecycle ‚Äî **including committing the changes**:

  ```python
  with engine.connect() as conn:
      conn.execute(text("CREATE TABLE ..."))
      conn.commit()  # Required to persist the change
  ```

**Summary:** Use `to_sql()` for quick and automatic DataFrame-to-table operations. Use raw SQL with manual commits when you need precise control over table schemas or complex operations.


## üß™ PgAdmin Internal Structure (Observed)

Once the container is running properly, the `pgadmin_data` folder will contain:

* `pgadmin4.db` ‚Äì Internal database with saved connections and settings.
* `sessions/` ‚Äì Temporary login session data.
* `storage/` ‚Äì File manager storage area for uploads/downloads.
* `azurecredentialcache/` ‚Äì Related to optional integration.

You should **avoid modifying these files manually** unless explicitly required.

---

## ‚úÖ Good Practices Implemented

* Bind mounts are used **with `:rw` mode and quoted paths** to avoid YAML parsing issues.
* Environment variables are defined in a `.env` file for flexible configuration.
* SQL scripts are logically organized in `sql/` by purpose (`ddl`, `dml`, `queries`, `tests`).
* Folder structure reflects a full mini-pipeline: from raw data to processing and querying.

---

## üõ† Future Improvements

* Add a `reset_db.sh` script to safely remove and recreate the database volumes.
* Include example datasets and query challenges in the `sql/queries/` folder.
* Expand `src/` with Python utilities for automated data ingestion and transformation.

---

**Maintained by:** \[Mazkaizo]
**Repository:** [https://github.com/Maxkaizo/sql_practice](https://github.com/Maxkaizo/sql_practice)

```